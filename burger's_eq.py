# -*- coding: utf-8 -*-
"""Burger's eq.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dnvrE10_bVBjPgOIcO7Rqoecj4UKCdk-
"""



"""Solving one dimensional Burger's equation by using Rk4 method"""



import numpy as np
import matplotlib.pyplot as plt

# Parameters
nu = 0.1  # Kinematic viscosity
dt = 0.01  # Time step
dx = 0.1  # Spatial step
t_end = 0.1  # End time
x_end = 1.0  # End spatial coordinate

# Number of grid points
nt = int(t_end / dt)
nx = int(x_end / dx)

# Initialize velocity field u
u = np.zeros((nt, nx))
u[0, :] = np.sin(np.pi * np.arange(nx) / (nx - 1))
print(f"At time t = 0,  u = {u[0, :]}")

# Define 1st order space derivative
def space_deriv1(u,dx):
    return np.gradient(u, dx)

# Define 2nd order space derivative
def space_deriv2(u,dx):
    return np.gradient(np.gradient(u, dx), dx)

# RK4 method for Burger's equation
for t in range(1, nt):
    k1 = dt * (-u[t - 1, :] * space_deriv1(u[t - 1, :], dx) + nu*space_deriv2(u[t - 1, :], dx))

    k2 = dt * (-u[t - 1, :] * space_deriv1(u[t - 1, :] + 0.5 * k1, dx) + nu*space_deriv2(u[t - 1, :] + 0.5 * k1, dx))

    k3 = dt * (-u[t - 1, :] * space_deriv1(u[t - 1, :] + 0.5 * k2, dx) + nu*space_deriv2(u[t - 1, :] + 0.5 * k2, dx))

    k4 = dt * (-u[t - 1, :] * space_deriv1(u[t - 1, :] + k3, dx) + nu*space_deriv2(u[t - 1, :] + k3, dx))

    u[t, :] = u[t - 1, :] + (k1 + 2 * k2 + 2 * k3 + k4)/6
    print(f"At time t = {t},  u = {u[t, :]}")

# Plotting
plt.figure(figsize=(8, 6))
for i in range(nt):
    plt.plot(np.linspace(0, x_end, nx), u[i, :], label=f"t={i * dt:.2f}")
plt.xlabel('Spatial coordinate (x)')
plt.ylabel('Velocity (u)')
plt.title("Burger's Equation Solution")
plt.legend()
plt.grid(True)
plt.show()

