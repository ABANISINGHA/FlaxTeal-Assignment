# -*- coding: utf-8 -*-
"""Burger's eq.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zXLqAnh8uETfKVMBGHGfQ2II1W8bw-vR

**Solving one dimensional Burger's equation by using Rk4 method**
"""

# Importing required libraries
import numpy as np
import matplotlib.pyplot as plt

# Parameters
nu = 0.1  # Diffusion coefficient or Kinematic viscosity
dt = 0.01  # Time step
dx = 0.1  # Spatial step
t_end = 0.1  # End time
x_end = 1.0  # End spatial coordinate

# Number of grid points
nt = int(t_end / dt)  # Number of time steps
nx = int(x_end / dx)  # Number of spatial points

# Initialize velocity field u
u = np.zeros((nt, nx))  # Create a 2D array to hold velocity values, initialized to zero
u[0, :] = np.sin(np.pi * np.arange(nx) / (nx - 1))  # Initial condition for velocity field
print(f"At the time step 0, \n u = {u[0, :]}")  # Printing initial velocity field

# Define 1st order space derivative
def space_deriv1(u, dx):
    return np.gradient(u, dx)  # Calculating first derivative using numpy's gradient function

# Define 2nd order space derivative
def space_deriv2(u, dx):
    return np.gradient(np.gradient(u, dx), dx)  # Calculating second derivative using numpy's gradient function

# RK4 method for Burger's equation
for t in range(1, nt):
    # Calculating k1 term in RK4 method
    k1 = dt * (-u[t - 1, :] * space_deriv1(u[t - 1, :], dx) + nu * space_deriv2(u[t - 1, :], dx))

    # Calculating k2 term in RK4 method
    k2 = dt * (-u[t - 1, :] * space_deriv1(u[t - 1, :] + 0.5 * k1, dx) + nu * space_deriv2(u[t - 1, :] + 0.5 * k1, dx))

    # Calculating k3 term in RK4 method
    k3 = dt * (-u[t - 1, :] * space_deriv1(u[t - 1, :] + 0.5 * k2, dx) + nu * space_deriv2(u[t - 1, :] + 0.5 * k2, dx))
    # Calculating k4 term in RK4 method

    k4 = dt * (-u[t - 1, :] * space_deriv1(u[t - 1, :] + k3, dx) + nu * space_deriv2(u[t - 1, :] + k3, dx))

    # Update velocity field using RK4 method
    u[t, :] = u[t - 1, :] + (k1 + 2 * k2 + 2 * k3 + k4) / 6

    # Printing the velocity field at current time step
    print(f"At the time step {t}, \n u = {u[t, :]}")

# Plotting
plt.figure(figsize=(8, 6))  # Creating a new figure with

# Plot velocity field for each time step
for i in range(nt):
    plt.plot(np.linspace(0, x_end, nx), u[i, :], label=f"t={i * dt:.2f}")

plt.xlabel('Spatial coordinate (x)')  # Setting of x-axis label
plt.ylabel('Velocity (u)')  # Setting of y-axis label
plt.title("Burger's Equation Solution")  # Setting of plot title
plt.legend()  # Show legend
plt.grid(True)  # Enable grid
plt.show()  # Display the plot

